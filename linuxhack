#!/bin/bash

set -e

test "$(id -u)" = 0

if [[ 1 = $(grep ' /dev/uhid ' /run/tmpfiles.d/kmod.conf | wc -l) ]]; then
  #
  # Originally /dev/uhid is only readable/writable by root, but we want v2f.py
  # process (usually executed with user id != 0) to access it in order to create
  # HID devices.  To achieve that, we can just make /dev/uhid universally
  # readable and universally writable.  For some obvious reason, it is less
  # secure.  Yet it works.
  #
  # /run/tmpfiles.d/kmod.conf should contain a line like this
  #
  #     c! /dev/uhid 0600 - - - 10:239
  #
  # Let us create a new file /etc/tmpfiles.d/expose-uhid.conf containing
  #
  #     c! /dev/uhid 0666 - - - 10:239
  #
  grep ' /dev/uhid ' /run/tmpfiles.d/kmod.conf | sed 's@ 0600 @ 0666 @' > /etc/tmpfiles.d/expose-uhid.conf
  > /dev/uhid
  sleep .5
  chmod 0666 /dev/uhid
fi

if [[ ! -f /etc/udev/rules.d/99-expose-all-hidraw.rules ]]; then
  #
  # When you plug in a Yubico U2F security key, a corresponding hidraw device
  # node is created, and it is usually named named like "/dev/hidraw0".  When
  # you use /dev/uhid ABI to create a new HID device, same thing happens.  I
  # don't know exactly how Google Chrome interacts with U2F devices yet, but I
  # do know that if I make the hidraw device node corresponding to the virtual
  # HID created by v2f.py universally readable and universally writable, Google
  # Chrome will be able to interact with it too.
  #
  # Sadly I don't know a good way to automatically `chmod 0666 /dev/hidrawN`
  # whenever I use v2f.py to create a new U2F HID device.
  #
  # Therefore, here is a quick hack which makes all hidraw device nodes
  # universally readable and universally writable.  For some obvious reason, it
  # is less secure.  Yet it works.
  #
  echo 'KERNEL=="hidraw*", SUBSYSTEM=="hidraw", MODE="0666"' > /etc/udev/rules.d/99-expose-all-hidraw.rules
  udevadm trigger
fi
